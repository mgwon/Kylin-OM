import os
import json
import uuid
from flask import Blueprint, jsonify, request
from filelock import FileLock
from flask_cors import CORS
import time
from threading import Thread

# --- 数据文件路径配置 ---
# 假设您的数据文件存放在项目根目录下的 'data/vulnerability/' 文件夹中
# 请根据您的实际项目结构进行调整
current_dir = os.path.dirname(os.path.abspath(__file__))
# 从当前目录向上回溯两级，然后进入 data/api_data/vulnerability
DATA_DIR = os.path.join(current_dir, '..', '..', 'data', 'api_data', 'vulnerability')
HOSTS_FILE = os.path.join(DATA_DIR, 'host-list','hosts.txt')
REPOS_FILE = os.path.join(DATA_DIR, 'host-list', 'repos.txt')
CVES_ALL_FILE = os.path.join(DATA_DIR, 'cves', 'all.txt')
CVES_DETAIL_DIR = os.path.join(DATA_DIR, 'cves')
RECORDS_LIST_FILE = os.path.join(DATA_DIR, 'vulnerability-records', 'list.txt')
RECORDS_DETAILS_FILE = os.path.join(DATA_DIR, 'vulnerability-records', 'details.txt')

# --- 创建蓝图 ---
vulnerability_bp = Blueprint('vulnerability', __name__)

CORS(vulnerability_bp)


# --- 文件读写辅助函数 (从 main_app.py 借鉴并加强) ---
def read_json_file(path, default_value=None):
    """安全地读取一个JSON文件"""
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return default_value if default_value is not None else []


def write_json_file(path, data):
    """安全地写入一个JSON文件"""
    lock_path = path + ".lock"
    lock = FileLock(lock_path)
    with lock:
        # 确保目录存在
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)


# --- API 路由实现 ---

# === 主机列表 (VulnerabilityHostList.js) ===

@vulnerability_bp.route('/hosts', methods=['GET'])
def get_hosts():
    """获取主机列表, 支持按名称搜索"""
    search_term = request.args.get('name', '').lower()
    all_hosts = read_json_file(HOSTS_FILE)
    if search_term:
        filtered_hosts = [h for h in all_hosts if search_term in h.get('name', '').lower()]
        return jsonify(filtered_hosts)
    return jsonify(all_hosts)


@vulnerability_bp.route('/hosts/<int:host_id>', methods=['GET'])
def get_host_details(host_id):
    """获取单个主机的详细信息"""
    all_hosts = read_json_file(HOSTS_FILE)
    host = next((h for h in all_hosts if h.get('id') == host_id), None)
    if host:
        return jsonify(host)
    return jsonify({"error": "Host not found"}), 404


# === CVE REPO (CveRepoPanel) ===

@vulnerability_bp.route('/repos', methods=['GET'])
def get_repos():
    """获取所有 CVE REPO"""
    repos = read_json_file(REPOS_FILE)
    return jsonify(repos)


@vulnerability_bp.route('/repos', methods=['POST'])
def add_repo():
    """新增一个 CVE REPO"""
    data = request.get_json()
    if not data or 'name' not in data or 'content' not in data:
        return jsonify({"error": "Missing name or content"}), 400

    repos = read_json_file(REPOS_FILE)
    new_repo = {
        "id": f"repo-{uuid.uuid4().hex[:6]}",
        "name": data['name'],
        "content": data['content']
    }
    repos.append(new_repo)
    write_json_file(REPOS_FILE, repos)
    return jsonify(new_repo), 201


@vulnerability_bp.route('/repos/<repo_id>', methods=['DELETE'])
def delete_repo(repo_id):
    """删除一个 CVE REPO"""
    repos = read_json_file(REPOS_FILE)
    repo_to_delete = next((r for r in repos if r.get('id') == repo_id), None)

    if not repo_to_delete:
        return jsonify({"error": "Repo not found"}), 404

    updated_repos = [r for r in repos if r.get('id') != repo_id]
    write_json_file(REPOS_FILE, updated_repos)
    return jsonify({"message": "Repo deleted successfully"}), 200


# === CVE 管理 (CVEs.js) ===

@vulnerability_bp.route('/cves', methods=['GET'])
def get_cves():
    """获取 CVE 列表"""
    cves = read_json_file(CVES_ALL_FILE)
    return jsonify(cves)


@vulnerability_bp.route('/cves/<path:cve_id>', methods=['GET'])
def get_cve_detail(cve_id):
    """获取单个 CVE 的详情"""
    # Flask 默认会处理 URL 编码，但为保险起见，我们构建一个安全的文件路径
    safe_cve_id = cve_id.replace('/', '_').replace('\\', '_')
    file_path = os.path.join(CVES_DETAIL_DIR, f"{safe_cve_id}.txt")

    cve_detail = read_json_file(file_path, default_value=None)

    if cve_detail:
        return jsonify(cve_detail)
    else:
        # 尝试从 hosts.txt 中动态构建一个简化版详情
        all_hosts = read_json_file(HOSTS_FILE, [])
        affected_hosts_info = []
        for host in all_hosts:
            for cve in host.get('unfixed_cves', []):
                if cve.get('cve_id') == cve_id:
                    affected_hosts_info.append({
                        "hostname": host.get('name'), "ip": host.get('ip'), "group": host.get('group'),
                        "repo": host.get('repo'), "last_scan": host.get('lastScan'), "status": "未修复"
                    })
            for cve in host.get('fixed_cves', []):
                if cve.get('cve_id') == cve_id:
                    affected_hosts_info.append({
                        "hostname": host.get('name'), "ip": host.get('ip'), "group": host.get('group'),
                        "repo": host.get('repo'), "last_scan": host.get('lastScan'), "status": "已修复"
                    })
        if affected_hosts_info:
            return jsonify({"id": cve_id, "affected_hosts": affected_hosts_info})

    return jsonify({"error": f"Details for {cve_id} not found"}), 404


# === 修复任务/记录 (VulnerabilityRepairRecords.js) ===

@vulnerability_bp.route('/tasks', methods=['GET'])
def get_tasks():
    """获取所有修复任务记录"""
    records = read_json_file(RECORDS_LIST_FILE)
    return jsonify(records)


@vulnerability_bp.route('/tasks/<task_id>', methods=['GET'])
def get_task_detail(task_id):
    """获取单个任务的详情"""
    details_db = read_json_file(RECORDS_DETAILS_FILE, default_value={})
    task_details = details_db.get(task_id)
    if task_details:
        return jsonify(task_details)
    return jsonify({"error": "Task detail not found"}), 404


@vulnerability_bp.route('/tasks', methods=['POST'])
def create_task():
    """创建新任务 (修复、移除、REPO设置等)"""
    task_info = request.get_json()
    if not task_info or 'name' not in task_info or 'type' not in task_info:
        return jsonify({"error": "Missing task name or type"}), 400

    # --- 读取所有需要用到的文件 ---
    all_records = read_json_file(RECORDS_LIST_FILE, [])
    details_db = read_json_file(RECORDS_DETAILS_FILE, default_value={})

    # ▼▼▼ 新增：为REPO设置任务读取主机文件 ▼▼▼
    if task_info.get('type') == 'repo设置':
        all_hosts = read_json_file(HOSTS_FILE, [])
        host_map = {host['id']: host for host in all_hosts}  # 创建一个字典以便快速查找

    new_id = f"task-{uuid.uuid4().hex[:6]}"

    # --- 构建通用的列表记录和详情记录 ---
    new_record = {
        "id": new_id,
        "name": task_info.get("name"),
        "description": task_info.get("description", ""),
        "hostCount": len(task_info.get("host_ids", [])),  # 使用 host_ids 的长度
        "type": task_info.get("type"),
        "status": {
            "success": 0, "fail": 0, "running": 0,
            "unknown": len(task_info.get("host_ids", []))
        },
        "creationTime": task_info.get("creationTime")
    }

    new_detail = new_record.copy()
    new_detail['affected_hosts'] = task_info.get('affected_hosts', [])

    # --- 根据不同任务类型，添加特定字段和逻辑 ---
    task_type = task_info.get('type')

    if task_type == 'cve修复' or task_type == '热补丁移除':
        new_detail['cve_ids'] = task_info.get('cve_ids', [])

    # ▼▼▼ 新增：处理 "repo设置" 任务的特定逻辑 ▼▼▼
    elif task_type == 'repo设置':
        repo_id = task_info.get('repo_id')
        host_ids = task_info.get('host_ids', [])

        if not repo_id or not host_ids:
            return jsonify({"error": "Missing repo_id or host_ids for repo setting task"}), 400

        new_detail['repo_id'] = repo_id
        new_detail['host_ids'] = host_ids

        # --- 核心业务逻辑：修改主机文件 ---
        updated_count = 0
        for host_id in host_ids:
            if host_id in host_map:
                # 找到对应的主机并更新其 'repo' 字段
                host_map[host_id]['repo'] = repo_id  # 或者可以是 repo 的名字，取决于你的设计
                updated_count += 1

        if updated_count > 0:
            # 将更新后的主机列表写回文件
            write_json_file(HOSTS_FILE, list(host_map.values()))
            # 你也可以在这里直接更新任务状态为成功
            # new_record['status']['success'] = updated_count
            # new_record['status']['unknown'] = 0

    # --- 将新任务记录写入文件 ---
    all_records.insert(0, new_record)
    details_db[new_id] = new_detail

    write_json_file(RECORDS_LIST_FILE, all_records)
    write_json_file(RECORDS_DETAILS_FILE, details_db)

    return jsonify(new_record), 201


@vulnerability_bp.route('/tasks', methods=['DELETE'])
def delete_tasks():
    """批量删除任务"""
    data = request.get_json()
    ids_to_delete = data.get('ids')
    if not ids_to_delete or not isinstance(ids_to_delete, list):
        return jsonify({"error": "Invalid or missing 'ids' list"}), 400

    all_records = read_json_file(RECORDS_LIST_FILE, [])
    details_db = read_json_file(RECORDS_DETAILS_FILE, default_value={})

    updated_records = [r for r in all_records if r.get('id') not in ids_to_delete]
    for task_id in ids_to_delete:
        if task_id in details_db:
            del details_db[task_id]

    write_json_file(RECORDS_LIST_FILE, updated_records)
    write_json_file(RECORDS_DETAILS_FILE, details_db)

    return jsonify({"message": f"Successfully deleted {len(ids_to_delete)} tasks"}), 200


@vulnerability_bp.route('/tasks/<task_id>/execute', methods=['POST'])
def execute_task(task_id):
    """执行任务 (模拟)"""
    all_records = read_json_file(RECORDS_LIST_FILE, [])
    details_db = read_json_file(RECORDS_DETAILS_FILE, default_value={})

    task_record = next((r for r in all_records if r.get('id') == task_id), None)
    task_detail = details_db.get(task_id)

    if not task_record or not task_detail:
        return jsonify({"error": "Task not found"}), 404

    # 模拟执行成功
    total_hosts = task_record['status']['success'] + task_record['status']['fail'] + \
                  task_record['status']['running'] + task_record['status']['unknown']

    task_record['status'] = {"success": total_hosts, "fail": 0, "running": 0, "unknown": 0}

    if 'affected_hosts' in task_detail:
        for host in task_detail['affected_hosts']:
            # 这里可以根据任务类型添加更复杂的逻辑
            host['repairStatus'] = "修复成功"
            host['repairStatusColor'] = "text-green-500"

    # 将更新写回文件
    write_json_file(RECORDS_LIST_FILE, all_records)
    write_json_file(RECORDS_DETAILS_FILE, details_db)

    # TODO: 在真实场景中，这里还需要更新 hosts.txt 和 cves/all.txt 的状态

    return jsonify({"message": f"Task {task_id} executed successfully (simulated)"}), 200


def perform_actual_scan(host_ip, host_id):
    """
    这是一个模拟的后台扫描函数。
    在真实世界中，这里会包含复杂的逻辑。
    """
    print(f"【后台线程】开始扫描主机 {host_ip} (ID: {host_id})...")

    # --- 在这里替换为您的真实扫描逻辑 ---
    # 示例:
    # 1. 使用 paramiko 或 subprocess 通过 SSH 连接到 host_ip
    #    ssh_client = paramiko.SSHClient()
    #    ssh_client.connect(host_ip, username='user', password='pass')
    # 2. 在远程主机上执行扫描命令
    #    stdin, stdout, stderr = ssh_client.exec_command('trivy rootfs / --format json')
    # 3. 获取并解析扫描结果
    #    scan_results = json.load(stdout)
    #    new_unfixed_cves = parse_trivy_results(scan_results) # 您需要自己实现这个解析函数

    # 模拟一个耗时 15 秒的扫描
    time.sleep(15)

    # --- 扫描完成后，更新数据文件 ---
    print(f"【后台线程】扫描 {host_ip} 完成，正在更新数据文件...")

    # 使用文件锁来安全地读写 hosts.txt
    lock = FileLock(HOSTS_FILE + ".lock")
    with lock:
        all_hosts = read_json_file(HOSTS_FILE, [])
        for host in all_hosts:
            if host.get('id') == host_id:
                # 假设我们找到了一些新的CVE
                host['cve'] = "5/3"  # 更新CVE数量
                host['cve_stats']['unfixed'] = 5
                host['cve_stats']['fixed'] = 3
                # 更新unfixed_cves和fixed_cves列表 (此处省略)
                host['lastScan'] = time.strftime("%Y-%m-%d %H:%M:%S")
                break

        # 将更新后的列表写回文件
        # 注意: write_json_file 函数中已有锁，但在这里外层加锁更安全，
        # 因为我们有“读-改-写”的原子性需求。
        with open(HOSTS_FILE, 'w', encoding='utf-8') as f:
            json.dump(all_hosts, f, ensure_ascii=False, indent=2)

    print(f"【后台线程】主机 {host_id} 的数据已更新。")


@vulnerability_bp.route('/scans', methods=['POST'])
def create_scan_task():
    """接收前端请求，为每个主机启动一个后台扫描线程"""
    data = request.get_json()
    host_ids = data.get('host_ids')

    if not host_ids:
        return jsonify({"error": "缺少 'host_ids' 参数"}), 400

    all_hosts = read_json_file(HOSTS_FILE, [])
    hosts_to_scan = [h for h in all_hosts if h.get('id') in host_ids]

    for host in hosts_to_scan:
        # 为每个主机创建一个新的后台线程来执行扫描
        # target=perform_actual_scan 指定了线程要执行的函数
        # args=(...) 传递了函数需要的参数
        scan_thread = Thread(target=perform_actual_scan, args=(host.get('ip'), host.get('id')))
        scan_thread.daemon = True  # 设置为守护线程，主程序退出时线程也退出
        scan_thread.start()  # 启动线程
        print(f"已为 {host.get('ip')} 创建扫描线程。")

    task_id = f"scan-task-{uuid.uuid4().hex[:6]}"
    return jsonify({
        "message": f"已为 {len(hosts_to_scan)} 台主机启动扫描任务。",
        "task_id": task_id
    }), 202  # 202 Accepted 表示服务器已接受请求，但处理尚未完成